<!DOCTYPE html>
<html lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <link rel="prefetch" href="https://fonts.gstatic.com/s/lora/v32/0QI6MX1D_JOuGQbT0gvTJPa787weuxJBkq0.woff2" as="font" type="font/woff2">
  <link rel="prefetch" href="https://fonts.gstatic.com/s/vollkorn/v22/0ybgGDoxxrvAnPhYGzMlQLzuMasz6Df2MHGeHmmc.woff2" as="font" type="font/woff2">
  <link rel="prefetch" href="https://fonts.gstatic.com/s/vollkorn/v22/0ybuGDoxxrvAnPhYGxksckM2WMCpRjDj-DJGWlmeObQ.woff2" as="font" type="font/woff2">
  <link rel="prefetch" href="https://fonts.gstatic.com/s/lora/v32/0QI8MX1D_JOuMw_hLdO6T2wV9KnW-MoFoq92nA.woff2" as="font" type="font/woff2">
  <link rel="prefetch" href="https://fonts.gstatic.com/s/spectral/v5/rnCr-xNNww_2s0amA9M5knjsS_ul.woff2" as="font" type="font/woff2">
  <meta name="color-scheme" content="dark light">
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes" />


  <link rel="prev" href="html.html" />
  <link rel="next" href="styles.html" />
  <link rel="stylesheet" href="book.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Vollkorn%7CLora&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Vollkorn:400i%7CLora:400i&display=swap" />
  <link rel="alternate" type="application/rss+xml" href="rss.xml" title="Web Browser Engineering">

  <title>Laying Out Pages | Web Browser Engineering</title>

</head>

<body>


<header>
<h1 class="title">Laying Out Pages</h1>
<a href="https://twitter.com/browserbook">Twitter</a> ·
<a href="https://browserbook.substack.com/">Blog</a> ·
<a href="https://patreon.com/browserengineering">Patreon</a> ·
<a href="https://github.com/browserengineering/book/discussions">Discussions</a>
</header>

<nav class="links">
  Chapter 5 of <a href="index.html" title="Table of Contents">Web Browser Engineering</a>.
  <a rel="prev" title="Previous chapter" href="html.html">&lt;</a>
  <a rel="next" title="Next chapter" href="styles.html">&gt;</a>
</nav>

<nav id="toc">
<ul>
<li><a href="#the-layout-tree" id="toc-the-layout-tree">The layout
tree</a></li>
<li><a href="#block-layout" id="toc-block-layout">Block layout</a></li>
<li><a href="#size-and-position" id="toc-size-and-position">Size and
position</a></li>
<li><a href="#recursive-painting" id="toc-recursive-painting">Recursive
painting</a></li>
<li><a href="#backgrounds" id="toc-backgrounds">Backgrounds</a></li>
<li><a href="#summary" id="toc-summary">Summary</a></li>
<li><a href="#outline" id="toc-outline">Outline</a></li>
<li><a href="#exercises" id="toc-exercises">Exercises</a></li>
</ul>
</nav>

<p>So far, layout has been a linear process that handles open tags and
close tags independently. But web pages are trees, and look like them:
borders and backgrounds visually nest inside one another. To support
that, this chapter switches to <em>tree-based layout</em>, where the
tree of elements is transformed into a tree of <em>layout objects</em>
for the visual elements of the page. In the process, we’ll make our web
pages more colorful with backgrounds.</p>
<h1 id="the-layout-tree">The layout tree</h1>
<p>Right now, our browser lays out an element’s open and close tags
separately. Both tags modify global state, like the
<code>cursor_x</code> and <code>cursor_y</code> variables, but they
aren’t otherwise connected, and information about the element as a
whole, like its width and height, is never computed. That makes it
pretty hard to draw a background color behind text. So web browsers
structure layout differently.</p>
<p>In a browser, layout is about producing a <em>layout tree</em>, whose
nodes are <em>layout objects</em>, each associated with an HTML
element,<span class="note-container"><span class="note">Elements like
<code>&lt;script&gt;</code> don’t generate layout objects, and some
elements generate multiple (<code>&lt;li&gt;</code> elements have a
layout object for the bullet point!), but mostly it’s one layout object
each.</span></span> and each with a size and a position. The browser
walks the HTML tree to produce the layout tree, then computes the size
and position for each layout object, and finally draws each layout
object to the screen.</p>
<p>Let’s start by looking how the existing <code>Layout</code> class is
used:</p>
<div class="sourceCode" id="cb1" data-expected="False"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load(<span class="va">self</span>, url):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> Layout(<span class="va">self</span>.nodes).display_list</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">#...</span></span></code></pre></div>
<p>Here, a <code>Layout</code> object is created briefly and then thrown
away. Let’s instead make it the beginning of our layout tree by storing
it in a <code>Browser</code> field:</p>
<div class="sourceCode" id="cb2" data-expected="False"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load(<span class="va">self</span>, url):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.document <span class="op">=</span> Layout(<span class="va">self</span>.nodes)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.document.layout()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> <span class="va">self</span>.document.display_list</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">#...</span></span></code></pre></div>
<p>Note that I’ve renamed the <code>Layout</code> constructor to a
<code>layout</code> method, so that constructing a layout object and
actually laying it out can be different steps. The constructor now just
stores the node it was passed:</p>
<div class="sourceCode" id="cb3" data-replace="Layout/BlockLayout"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Layout:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, node):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span></code></pre></div>
<p>So far, we still don’t have a tree—we just have a single
<code>Layout</code> object. To make it into a tree, we’ll need add child
and parent pointers. I’m also going to add a pointer to the previous
sibling, because that’ll be useful for computing sizes and positions
later:</p>
<div class="sourceCode" id="cb4" data-replace="Layout/BlockLayout"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Layout:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, node, parent, previous):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.previous <span class="op">=</span> previous</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span></code></pre></div>
<p>That said, requiring a <code>parent</code> and <code>previous</code>
element now makes it tricky to construct a <code>Layout</code> object in
<code>Browser</code>, since the root of the layout tree obviously can’t
have a parent. To rectify that, let me add a second kind of layout
object to serve as the root of the layout tree.<span
class="note-container"><span class="note">I don’t want to just pass
<code>None</code> for the parent, because the root layout object also
computes its size and position differently, as we’ll see later this
chapter.</span></span> I think of that root as the document itself, so
let’s call it <code>DocumentLayout</code>:</p>
<div class="sourceCode" id="cb5" data-replace="%20Layout/%20BlockLayout"
data-dropline="display_list"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DocumentLayout:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, node):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> Layout(<span class="va">self</span>.node, <span class="va">self</span>, <span class="va">None</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children.append(child)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        child.layout()</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> child.display_list</span></code></pre></div>
<p>Note an interesting thing about this new <code>layout</code> method:
its role is to <em>create</em> the child layout objects, and then
<em>recursively</em> call its children’s <code>layout</code> methods.
This is a common pattern for constructing trees, and we’ll be seeing it
a lot throughout this book.</p>
<p>Now when we construct a <code>DocumentLayout</code> object inside
<code>load</code>, we’ll be building a tree! A very short tree, more of
a stump for now, but it’s something!</p>
<p>By the way, since we now have <code>DocumentLayout</code>, let’s
rename <code>Layout</code> so it’s less ambiguous. I like
<code>BlockLayout</code> as a name, because we ultimately want
<code>Layout</code> to represent a block of text, like a paragraph or a
heading:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span></code></pre></div>
<p>Make sure to rename the <code>Layout</code> constructor call in
<code>DocumentLayout</code> as well. Test your browser and make sure
that after all of these refactors, everything still works.</p>
<div class="further">
<p>The layout tree isn’t accessible to web developers, so it hasn’t been
standardized, and its structure differs between browsers. Even the names
don’t match! Chrome calls it a <a
href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">layout
tree</a>, Safari a <a
href="https://webkit.org/blog/114/webcore-rendering-i-the-basics/">render
tree</a>, and Firefox a <a
href="https://wiki.mozilla.org/Gecko:Key_Gecko_Structures_And_Invariants">frame
tree</a>.</p>
</div>
<h1 id="block-layout">Block layout</h1>
<p>So far, we’ve focused on text layout—and text is laid out
horizontally in lines.<span class="note-container"><span class="note">In
European languages, at least!</span></span> But web pages are really
constructed out of larger blocks, like headings, paragraphs, and menus,
that are stacked vertically one after another. We need to add support
for this kind of layout to our browser, and the way we’re going to do
that involves expanding on the layout tree we’ve already built.</p>
<p>The core idea is that we’ll have a whole tree of
<code>BlockLayout</code> objects (with a <code>DocumentLayout</code> at
the root). Some will represent leaf blocks that contain text, and
they’ll lay out their contents the way we’ve already implemented. But
there will also be new, intermediate <code>BlockLayout</code>s with
<code>BlockLayout</code> children, and they will stack their children
vertically.</p>
<p>To create these intermediate <code>BlockLayout</code> children, we
can use a loop like this:</p>
<div class="sourceCode" id="cb7"
data-replace="layout_intermediate/layout"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout_intermediate(<span class="va">self</span>):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        previous <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.node.children:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="bu">next</span> <span class="op">=</span> BlockLayout(child, <span class="va">self</span>, previous)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.append(<span class="bu">next</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            previous <span class="op">=</span> <span class="bu">next</span></span></code></pre></div>
<p>I’ve called this method <code>layout_intermediate</code>, but only so
you can add it to the code right away and then compare it with the
existing <code>recurse</code> method.</p>
<p>This code is tricky, so read it carefully. It involves two trees: the
HTML tree, which <code>node</code> and <code>child</code> point to; and
the layout tree, which <code>self</code>, <code>previous</code>, and
<code>next</code> point to. The two trees have similar structure, so
it’s easy to get confused. But remember that this code constructs the
layout tree from the HTML tree, so it reads from
<code>node.children</code> (in the HTML tree) and writes to
<code>self.children</code> (in the layout tree).</p>
<p>So we have two ways to lay out an element: either calling
<code>recurse</code> and <code>flush</code>, or this
<code>layout_intermediate</code> function. To determine which one a
layout object should use, we’ll need to know what kind of content its
HTML node contains: text and text-related tags like
<code>&lt;b&gt;</code>, or blocks like <code>&lt;p&gt;</code> and
<code>&lt;h1&gt;</code>. That function looks something like this:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> layout_mode(node):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(node, Text):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;inline&quot;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> node.children:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">any</span>([<span class="bu">isinstance</span>(child, Element) <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                child.tag <span class="kw">in</span> BLOCK_ELEMENTS</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> child <span class="kw">in</span> node.children]):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;block&quot;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;inline&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;block&quot;</span></span></code></pre></div>
<p>Here the list of <code>BLOCK_ELEMENTS</code> is basically what you
expect, a list of all the tags that describe parts of a page instead of
formatting:<span class="note-container"><span class="note">Taken from
the <a href="https://html.spec.whatwg.org/multipage/#toc-semantics">HTML
living standard</a>.</span></span></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>BLOCK_ELEMENTS <span class="op">=</span> [</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;html&quot;</span>, <span class="st">&quot;body&quot;</span>, <span class="st">&quot;article&quot;</span>, <span class="st">&quot;section&quot;</span>, <span class="st">&quot;nav&quot;</span>, <span class="st">&quot;aside&quot;</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;h1&quot;</span>, <span class="st">&quot;h2&quot;</span>, <span class="st">&quot;h3&quot;</span>, <span class="st">&quot;h4&quot;</span>, <span class="st">&quot;h5&quot;</span>, <span class="st">&quot;h6&quot;</span>, <span class="st">&quot;hgroup&quot;</span>, <span class="st">&quot;header&quot;</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;footer&quot;</span>, <span class="st">&quot;address&quot;</span>, <span class="st">&quot;p&quot;</span>, <span class="st">&quot;hr&quot;</span>, <span class="st">&quot;pre&quot;</span>, <span class="st">&quot;blockquote&quot;</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ol&quot;</span>, <span class="st">&quot;ul&quot;</span>, <span class="st">&quot;menu&quot;</span>, <span class="st">&quot;li&quot;</span>, <span class="st">&quot;dl&quot;</span>, <span class="st">&quot;dt&quot;</span>, <span class="st">&quot;dd&quot;</span>, <span class="st">&quot;figure&quot;</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;figcaption&quot;</span>, <span class="st">&quot;main&quot;</span>, <span class="st">&quot;div&quot;</span>, <span class="st">&quot;table&quot;</span>, <span class="st">&quot;form&quot;</span>, <span class="st">&quot;fieldset&quot;</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;legend&quot;</span>, <span class="st">&quot;details&quot;</span>, <span class="st">&quot;summary&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>Our <code>layout_mode</code> function has to handle one tricky case,
where a node contains both block children like a <code>&lt;p&gt;</code>
element but also text children like a text node or a
<code>&lt;b&gt;</code> element. I’ve chosen to use block mode in this
case, but it’s probably best to think of this as a kind of error on the
part of the web developer. And just like with implicit tags in <a
href="html.html">Chapter 4</a>, we use a repair mechanism to make sense
of the situation.<span class="note-container"><span class="note">In real
browsers, that repair mechanism is called “<a
href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes">anonymous
block boxes</a>” and is more complex than what’s described
here.</span></span></p>
<p>So now <code>BlockLayout</code> can determine what kind of layout to
do based on the <code>layout_mode</code> of its HTML node:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        mode <span class="op">=</span> layout_mode(<span class="va">self</span>.node)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mode <span class="op">==</span> <span class="st">&quot;block&quot;</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            previous <span class="op">=</span> <span class="va">None</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.node.children:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                <span class="bu">next</span> <span class="op">=</span> BlockLayout(child, <span class="va">self</span>, previous)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.children.append(<span class="bu">next</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                previous <span class="op">=</span> <span class="bu">next</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.display_list <span class="op">=</span> []</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_x <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_y <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.weight <span class="op">=</span> <span class="st">&quot;normal&quot;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.style <span class="op">=</span> <span class="st">&quot;roman&quot;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.size <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.line <span class="op">=</span> []</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.recurse(<span class="va">self</span>.node)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.flush()</span></code></pre></div>
<p>Finally, since <code>BlockLayout</code>s can now have children, the
<code>layout</code> method next needs to recursively call
<code>layout</code> so those children can construct their children, and
so on recursively:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            child.layout()</span></code></pre></div>
<p>We also need to gather their <code>display_list</code> fields into a
single array:</p>
<div class="sourceCode" id="cb12" data-expected="False"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.display_list.extend(child.display_list)</span></code></pre></div>
<p>Our browser is now constructing a whole tree of
<code>BlockLayout</code> objects; in fact, if you add a
<code>print_tree</code> call to <code>Browser</code>’s <code>load</code>
method, you’ll see that large web pages like this chapter produce large
and complex layout trees!</p>
<iframe class="widget" src="widgets/layout-container-example.html?embed=true" data-big-height="490px" data-small-height="860px"></iframe>
<p>Oh, you might also notice that the text on these web pages is now
totally unreadable, because it’s all overlapping at the top of the page.
Let’s fix that next.</p>
<div class="further">
<p>In CSS, the layout mode is set by the <a
href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code>
property</a>. The oldest CSS layout modes, like <code>inline</code> and
<code>block</code>, are set on the children instead of the parent, which
leads to hiccups like <a
href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes">anonymous
block boxes</a>. Newer properties like <code>inline-block</code>,
<code>flex</code>, and <code>grid</code> are set on the parent. This
chapter uses the newer, less confusing convention, even though it’s
actually implementing inline and block layout.</p>
</div>
<h1 id="size-and-position">Size and position</h1>
<p>In the <a href="html.html">previous chapter</a>, the
<code>Layout</code> object was responsible for the whole web page, so it
just laid out its content starting at the top of the page. Now that we
have multiple <code>BlockLayout</code> objects each containing a
different paragraph of text, we’re going to need to do things a little
differently, computing a size and position for each layout object
independently.</p>
<p>Let’s start with <code>cursor_x</code> and <code>cursor_y</code>.
Instead of having them denote absolute positions on the page, let’s make
them relative to the <code>BlockLayout</code> itself; they now need to
start from <code>0</code> instead of <code>HSTEP</code> and
<code>VSTEP</code>, both in <code>layout</code> and
<code>flush</code>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_x <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_y <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> flush(<span class="va">self</span>):</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cursor_x <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Since these fields are now relative, we’ll need to add the block’s
<code>x</code> and <code>y</code> position in <code>flush</code> when
computing the display list:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> flush(<span class="va">self</span>):</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rel_x, word, font <span class="kw">in</span> <span class="va">self</span>.line:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> <span class="va">self</span>.x <span class="op">+</span> rel_x</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> <span class="va">self</span>.y <span class="op">+</span> baseline <span class="op">-</span> font.metrics(<span class="st">&quot;ascent&quot;</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.display_list.append((x, y, word, font))</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Similarly, to wrap lines, we can’t compare <code>cursor_x</code> to
<code>WIDTH</code>, because <code>cursor_x</code> is a relative measure
while <code>WIDTH</code> is an absolute measure; instead, we’ll wrap
lines when <code>cursor_x</code> reaches the block’s
<code>width</code>:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> text(<span class="va">self</span>, node):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> word <span class="kw">in</span> node.text.split():</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>            <span class="co"># ...</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.cursor_x <span class="op">+</span> w <span class="op">&gt;</span> <span class="va">self</span>.width:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                <span class="co"># ...</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># ...</span></span></code></pre></div>
<p>So now that leaves us with the problem of computing these
<code>x</code>, <code>y</code>, and <code>width</code> fields. Let’s
recall that <code>BlockLayout</code>s represent blocks of text like
paragraphs or headings, and are stacked vertically one atop another.
That means each one starts at its parent’s left edge:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">self</span>.parent.x</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Its vertical position depends on the position and height of their
previous sibling. If there is no previous sibling, they start at the
parent’s top edge:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.previous:</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.y <span class="op">=</span> <span class="va">self</span>.previous.y <span class="op">+</span> <span class="va">self</span>.previous.height</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.y <span class="op">=</span> <span class="va">self</span>.parent.y</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Note that in each of these cases, to compute one block’s
<code>x</code> and <code>y</code>, the <code>x</code> and <code>y</code>
of its parent block must <em>already</em> have been computed. That means
these computations have to go <em>before</em> the recursive
<code>layout</code> call, so those children can compute their
<code>x</code> and <code>y</code> based on this block’s <code>x</code>
and <code>y</code>. Similarly, since the <code>y</code> position of a
block depends on its previous sibling’s <code>y</code> position, the
recursive <code>layout</code> calls have to start at the first sibling
and iterate through the list forward—which is how we’ve already done it,
but which will be an important constraint in <span class="link">later
chapters</span>.</p>
<p>Now we’ll need compute widths and heights. Width is easy: blocks are
as wide as their parents:<span class="note-container"><span
class="note">In the <a href="styles.html">next chapter</a>, we’ll add
support for author-defined styles, which in real browsers modify these
layout rules by setting custom widths or changing how <em>x</em> and
<em>y</em> position are computed.</span></span></p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.width <span class="op">=</span> <span class="va">self</span>.parent.width</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Height, meanwhile, is a little tricky. A <code>BlockLayout</code>
that contains other blocks should be tall enough to contain all of its
children, so its height should be the sum of its children’s heights:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mode <span class="op">==</span> <span class="st">&quot;block&quot;</span>:</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.height <span class="op">=</span> <span class="bu">sum</span>([</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                child.height <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children])</span></code></pre></div>
<p>However, a <code>BlockLayout</code> that contains text doesn’t have
children; instead, it needs to be tall enough to contain all its text,
which we can conveniently read off of <code>cursor_y</code>:<span
class="note-container"><span class="note">Since the height is just equal
to <code>cursor_y</code>, why not rename <code>cursor_y</code> to
<code>height</code> instead? You could, it would work fine, but I would
rather not. As you can see from, say, the <code>y</code> computation,
the <code>height</code> field is a public field, read by other layout
objects to compute their positions. As such I’d rather make sure it
<em>always</em> has the right value, whereas <code>cursor_y</code>
changes as we lay out a paragraph of text and therefore sometimes has
the “wrong” value. Keeping these two fields separate avoids a whole
class of nasty bugs where the <code>height</code> field is read “too
soon” and therefore gets the wrong value.</span></span></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.height <span class="op">=</span> <span class="va">self</span>.cursor_y</span></code></pre></div>
<p>Let’s think again about dependencies. Height has the opposite
dependencies compared to <code>x</code>, <code>y</code>, and
<code>width</code>: the <code>height</code> of a block depends on its
children’s heights. While <code>x</code>, <code>y</code>, and
<code>width</code> must be computed <em>before</em> the recursive call,
<code>height</code> has to be computed <em>after</em>, at the very end
of <code>layout</code>.</p>
<p>Finally, even <code>DocumentLayout</code> needs some layout code,
though since the document always starts in the same place it’s pretty
simple:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DocumentLayout:</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.width <span class="op">=</span> WIDTH <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>HSTEP</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> HSTEP</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> VSTEP</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        child.layout()</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.height <span class="op">=</span> child.height <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>VSTEP</span></code></pre></div>
<p>Note that there’s some padding around the contents—<code>HSTEP</code>
on the left and right, and <code>VSTEP</code> above and below. That’s so
the text won’t run into the very edge of the window and get cut off.</p>
<p>For all three types of layout object, the order of the steps in the
<code>layout</code> method should be the same:</p>
<ul>
<li>When <code>layout</code> is called, it first computes the
<code>width</code>, <code>x</code>, and <code>y</code> fields, reading
from the <code>parent</code> and <code>previous</code> layout
objects.</li>
<li>Next, it creates a child layout object for each child element.</li>
<li>Then, the child layout nodes are recursively laid out by calling
their <code>layout</code> methods.</li>
<li>Finally, <code>layout</code> computes the <code>height</code> field,
reading from the child layout objects.</li>
</ul>
<p>You can see these steps in action in this widget:</p>
<iframe class="widget" src="widgets/lab5-propagate.html" height="204"></iframe>
<p>This kind of dependency reasoning is crucial to layout and more
broadly to any kind of computation on trees. If you get the order of
operations wrong, some layout object will try to read a value that
hasn’t been computed yet, and the browser will have a bug. We’ll come
back to this issue of dependencies <span class="link">later</span>,
where it will become even more important.</p>
<p>Anyway, with all of the sizes and positions now computed correctly,
you should see the browser now correctly display all of the text on the
page.</p>
<div class="further">
<p>Formally, computations on a tree like this can be described by an <a
href="https://en.wikipedia.org/wiki/Attribute_grammar">attribute
grammar</a>. Attribute grammar engines analyze dependencies between
different attributes to determine the right order to traverse the tree
and calculate each attribute.</p>
</div>
<h1 id="recursive-painting">Recursive painting</h1>
<p>Our <code>layout</code> method is now doing quite a bit of work:
computing sizes and positions; creating child layout objects;
recursively laying out those child layout objects; and aggregating the
display lists so the text can be drawn to the screen. This is a bit
messy, so let’s take a moment to extract just one part of this, the
display list part. Along the way, we can stop copying the display list
contents over and over again as we go up the layout tree.</p>
<p>I think it’s most convenient to do that by adding a
<code>paint</code> function to each layout object, which appends any of
its own layout objects to the display list and then recursively paints
the child layouts. A neat trick here is to pass the list itself as an
argument, and have the recursive function append to that list. For
<code>DocumentLayout</code>, which only has one child, the recursion
looks like this:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DocumentLayout:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>, display_list):</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children[<span class="dv">0</span>].paint(display_list)</span></code></pre></div>
<p>You can now delete the line that computes a
<code>DocumentLayout</code>’s <code>display_list</code> field.</p>
<p>For a <code>BlockLayout</code> with multiple children,
<code>paint</code> is called on each child:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>, display_list):</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children:</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>            child.paint(display_list)</span></code></pre></div>
<p>Again, delete the line that computes a <code>BlockLayout</code>’s
<code>display_list</code> field by copying from child layout
objects.</p>
<p>Finally for a <code>BlockLayout</code> object with text inside, we
need to copy over the <code>display_list</code> field that it computes
during <code>recurse</code> and <code>flush</code>:</p>
<div class="sourceCode" id="cb24" data-expected="False"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>, display_list):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        display_list.extend(<span class="va">self</span>.display_list)</span></code></pre></div>
<p>Now the browser can use <code>paint</code> to collect its own
<code>display_list</code> variable:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load(<span class="va">self</span>, url):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> []</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.document.paint(<span class="va">self</span>.display_list)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.draw()</span></code></pre></div>
<p>Check it out: your browser is now using fancy tree-based layout! I
recommend pausing to test and debug. Tree-based layout is powerful but
complex, and we’re about to add more features. Stable foundations make
for comfortable houses.</p>
<div class="further">
<p>Layout trees are common <a
href="https://book.huihoo.com/debian-gnu-linux-desktop-survival-guide/Widget_Tree.html">in
GUI frameworks</a>, but there are other ways to structure layout, such
as constraint-based layout. TeX’s <a
href="https://www.overleaf.com/learn/latex/Articles/Boxes_and_Glue%3A_A_Brief%2C_but_Visual%2C_Introduction_Using_LuaTeX">boxes
and glue</a> and iOS <a
href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">auto-layout</a>
are two examples of this alternative paradigm.</p>
</div>
<h1 id="backgrounds">Backgrounds</h1>
<p>Browsers use the layout tree a lot,<span class="note-container"><span
class="note">For example, in <a href="chrome.html">Chapter 7</a>, we’ll
use the size and position of each link to figure out which one the user
clicked on.</span></span> and one simple and visually compelling use
case is drawing backgrounds.</p>
<p>Backgrounds are rectangles, so our first task is putting rectangles
in the display list. Conceptually, the display list contains
<em>commands</em>, and we want two types of commands:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawText:</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x1, y1, text, font):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.top <span class="op">=</span> y1</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> x1</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text <span class="op">=</span> text</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.font <span class="op">=</span> font</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawRect:</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x1, y1, x2, y2, color):</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.top <span class="op">=</span> y1</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> x1</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bottom <span class="op">=</span> y2</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> x2</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.color <span class="op">=</span> color</span></code></pre></div>
<p>Now <code>BlockLayout</code> must add <code>DrawText</code> objects
to the display list:<span class="note-container"><span class="note">Why
not change the <code>display_list</code> field inside an
<code>BlockLayout</code> to contain <code>DrawText</code> commands
directly? I suppose you could, but I think it’s cleaner this way, with
all of the draw commands created in one place.</span></span></p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>, display_list):</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x, y, word, font <span class="kw">in</span> <span class="va">self</span>.display_list:</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>            display_list.append(DrawText(x, y, word, font))</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Note that we must add the block’s <code>x</code> and <code>y</code>,
since the positions in the display list are relative to the block’s
position.</p>
<p>But it can also add <code>DrawRect</code> commands for backgrounds.
Let’s add a gray background to <code>pre</code> tags (which are used for
code examples):</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>, display_list):</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.node, Element) <span class="kw">and</span> <span class="va">self</span>.node.tag <span class="op">==</span> <span class="st">&quot;pre&quot;</span>:</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>            x2, y2 <span class="op">=</span> <span class="va">self</span>.x <span class="op">+</span> <span class="va">self</span>.width, <span class="va">self</span>.y <span class="op">+</span> <span class="va">self</span>.height</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>            rect <span class="op">=</span> DrawRect(<span class="va">self</span>.x, <span class="va">self</span>.y, x2, y2, <span class="st">&quot;gray&quot;</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>            display_list.append(rect)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Make sure this code comes <em>before</em> the loop that adds
<code>DrawText</code> objects and <em>before</em> the recursion into
child layout objects: the background has to be drawn <em>below</em> and
therefore <em>before</em> any contents. This is again a kind of
dependency reasoning with tree traversals!</p>
<p>With the display list filled out, we need the <code>paint</code>
method to run each graphics command. Let’s add an <code>execute</code>
method for this. On <code>DrawText</code> it calls
<code>create_text</code>:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawText:</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, scroll, canvas):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        canvas.create_text(</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left, <span class="va">self</span>.top <span class="op">-</span> scroll,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>            text<span class="op">=</span><span class="va">self</span>.text,</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            font<span class="op">=</span><span class="va">self</span>.font,</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>            anchor<span class="op">=</span><span class="st">&#39;nw&#39;</span>,</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<p>Note that <code>execute</code> takes the scroll amount as a
parameter; this way, each graphics command does the relevant coordinate
conversion itself. <code>DrawRect</code> does the same with
<code>create_rectangle</code>:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawRect:</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, scroll, canvas):</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>        canvas.create_rectangle(</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left, <span class="va">self</span>.top <span class="op">-</span> scroll,</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.right, <span class="va">self</span>.bottom <span class="op">-</span> scroll,</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>            width<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>            fill<span class="op">=</span><span class="va">self</span>.color,</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<p>By default, <code>create_rectangle</code> draws a one-pixel black
border, which for backgrounds we don’t want, so make sure to pass
<code>width = 0</code>:</p>
<p>We still want to skip offscreen graphics commands, so let’s add a
<code>bottom</code> field to <code>DrawText</code> so we know when to
skip those:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x1, y1, text, font):</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.bottom <span class="op">=</span> y1 <span class="op">+</span> font.metrics(<span class="st">&quot;linespace&quot;</span>)</span></code></pre></div>
<p>The browser’s <code>draw</code> method now just uses <code>top</code>
and <code>bottom</code> to decide which commands to
<code>execute</code>:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> draw(<span class="va">self</span>):</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.canvas.delete(<span class="st">&quot;all&quot;</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> cmd <span class="kw">in</span> <span class="va">self</span>.display_list:</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cmd.top <span class="op">&gt;</span> <span class="va">self</span>.scroll <span class="op">+</span> HEIGHT: <span class="cf">continue</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cmd.bottom <span class="op">&lt;</span> <span class="va">self</span>.scroll: <span class="cf">continue</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>            cmd.execute(<span class="va">self</span>.scroll, <span class="va">self</span>.canvas)</span></code></pre></div>
<p>Try your browser on a page—maybe this one—with code snippets on it.
You should see each code snippet set off with a gray background.</p>
<div class="quirk">
<p>On some systems, the <code>measure</code> and <code>metrics</code>
commands are awfully slow. Adding another call makes things even
slower.</p>
<p>Luckily, this <code>metrics</code> call duplicates a call in
<code>flush</code>. If you’re careful you can pass the results of that
call to <code>DrawText</code> as an argument.</p>
</div>
<p>Here’s one more cute benefit of tree-based layout. Thanks to
tree-based layout we now record the height of the whole page. The
browser can use that to avoid scrolling past the bottom of the page:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> scrolldown(<span class="va">self</span>, e):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    max_y <span class="op">=</span> <span class="va">self</span>.document.height <span class="op">-</span> HEIGHT</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.scroll <span class="op">=</span> <span class="bu">min</span>(<span class="va">self</span>.scroll <span class="op">+</span> SCROLL_STEP, max_y)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.draw()</span></code></pre></div>
<p>So those are the basics of tree-based layout! In fact, as we’ll see
in the next two chapters, this is just part of the layout tree’s role in
the browser. But before we get to that, we need to add some styling
capabilities to our browser.</p>
<div class="further">
<p>The draft CSS <a
href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Painting_API/Guide">Painting
API</a> allows pages to extend the display list with new types of
commands, implemented in JavaScript. This makes it possible to use CSS
for styling with visually-complex styling provided by a library.</p>
</div>
<h1 id="summary">Summary</h1>
<p>This chapter was a dramatic rewrite of your browser’s layout
engine:</p>
<ul>
<li>Layout is now tree-based and produces a <em>layout tree</em></li>
<li>Each node in the tree has one of two different <em>layout
modes</em></li>
<li>Layout computes a size and position for each layout object</li>
<li>The display list now contains generic commands</li>
<li>Plus, source code snippets now have backgrounds</li>
</ul>
<p>Tree-based layout makes it possible to dramatically expand our
browser’s styling capabilities. We’ll work on that in the <a
href="styles.html">next chapter</a>.</p>
<div id="signup">
<iframe src="https://browserbook.substack.com/embed" width="350" height="180" frameborder="0" scrolling="no"></iframe>
<a href="#" id="signup-close">Close</a>
</div>

<h1 id="outline">Outline</h1>
<p>The complete set of functions, classes, and methods in our browser
should look something like this:</p>
<div class="cmd python outline">
<code class=line><span class=kw>def</span> request(url)
</code>
<code class=line>WIDTH
</code>
<code class=line>HEIGHT
</code>
<code class=line>HSTEP
</code>
<code class=line>VSTEP
</code>
<code class=line>SCROLL_STEP
</code>
<code class=line>FONTS
</code>
<code class=line><span class=kw>def</span> get_font(size, weight, slant)
</code>
<code class=line><span class=kw>class</span> Text:
<code class=line>    <span class=kw>def</span> __init__(text, parent)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>class</span> Element:
<code class=line>    <span class=kw>def</span> __init__(tag, attributes, parent)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>def</span> print_tree(node, indent)
</code>
<code class=line><span class=kw>class</span> HTMLParser:
<code class=line>    <span class=kw>def</span> __init__(body)
</code>
<code class=line>    <span class=kw>def</span> parse()
</code>
<code class=line>    <span class=kw>def</span> get_attributes(text)
</code>
<code class=line>    <span class=kw>def</span> add_text(text)
</code>
<code class=line>    SELF_CLOSING_TAGS
</code>
<code class=line>    <span class=kw>def</span> add_tag(tag)
</code>
<code class=line>    HEAD_TAGS
</code>
<code class=line>    <span class=kw>def</span> implicit_tags(tag)
</code>
<code class=line>    <span class=kw>def</span> finish()
</code>
</code>
<code class=line>BLOCK_ELEMENTS
</code>
<code class=line><span class=kw>def</span> layout_mode(node)
</code>
<code class=line><span class=kw>class</span> BlockLayout:
<code class=line>    <span class=kw>def</span> __init__(node, parent, previous)
</code>
<code class=line>    <span class=kw>def</span> layout()
</code>
<code class=line>    <span class=kw>def</span> recurse(node)
</code>
<code class=line>    <span class=kw>def</span> open_tag(tag)
</code>
<code class=line>    <span class=kw>def</span> close_tag(tag)
</code>
<code class=line>    <span class=kw>def</span> text(node)
</code>
<code class=line>    <span class=kw>def</span> flush()
</code>
<code class=line>    <span class=kw>def</span> paint(display_list)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>class</span> DocumentLayout:
<code class=line>    <span class=kw>def</span> __init__(node)
</code>
<code class=line>    <span class=kw>def</span> layout()
</code>
<code class=line>    <span class=kw>def</span> paint(display_list)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>class</span> DrawText:
<code class=line>    <span class=kw>def</span> __init__(x1, y1, text, font)
</code>
<code class=line>    <span class=kw>def</span> execute(scroll, canvas)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>class</span> DrawRect:
<code class=line>    <span class=kw>def</span> __init__(x1, y1, x2, y2, color)
</code>
<code class=line>    <span class=kw>def</span> execute(scroll, canvas)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>class</span> Browser:
<code class=line>    <span class=kw>def</span> __init__()
</code>
<code class=line>    <span class=kw>def</span> load(url)
</code>
<code class=line>    <span class=kw>def</span> draw()
</code>
<code class=line>    <span class=kw>def</span> scrolldown(e)
</code>
</code>
<code class=line><span class=cf>if</span> __name__ <span class=op>==</span> <span class=st>"__main__"</span>
</code>

</div>
<h1 id="exercises">Exercises</h1>
<p><em>Links Bar</em>: At the top and bottom of each chapter of this
book is a gray bar naming the chapter and offering back and forward
links. It is enclosed in a <code>&lt;nav class="links"&gt;</code> tag.
Have your browser give this links bar the light gray background a real
browser would.</p>
<p><em>Hidden Head</em>: There’s a good chance your browser is still
showing scripts, styles, and page titles at the top of every page you
visit. Make it so that the <code>&lt;head&gt;</code> element and its
contents are never displayed. Those elements should still be in the HTML
tree, but not in the layout tree.</p>
<p><em>Bullets</em>: Add bullets to list items, which in HTML are
<code>&lt;li&gt;</code> tags. You can make them little squares, located
to the left of the list item itself. Also indent <code>&lt;li&gt;</code>
elements so the text inside the element is to the right of the bullet
point.</p>
<p><em>Scrollbar</em>: At the right edge of the screen, draw a blue,
rectangular scrollbar. The ratio of its height to the screen height
should be the same as the ratio of the screen height to the document
height, and its location should reflect the position of the screen
within the document. Hide the scrollbar if the whole document fits
onscreen.</p>
<p><em>Table of Contents</em>: This book has a table of contents at the
top of each chapter, enclosed in a <code>&lt;nav id="toc"&gt;</code>
tag, which contains a list of links. Add the text “Table of Contents”,
with a gray background, above that list. Don’t modify the lexer or
parser.</p>
<p><em>Anonymous block boxes</em>: Sometimes, an element has a mix of
text-like and container-like children. For example, in this HTML,</p>
<pre><code>&lt;div&gt;&lt;i&gt;Hello, &lt;/i&gt;&lt;b&gt;world!&lt;/b&gt;&lt;p&gt;So it began...&lt;/p&gt;&lt;/div&gt;</code></pre>
<p>the <code>&lt;div&gt;</code> element has three children: the
<code>&lt;i&gt;</code>, <code>&lt;b&gt;</code>, and
<code>&lt;p&gt;</code> elements. The first two are text-like; the last
is container-like. This is supposed to look like two paragraphs, one for
the <code>&lt;i&gt;</code> and <code>&lt;b&gt;</code> and the second for
the <code>&lt;p&gt;</code>. Make your browser do that. Specifically,
modify <code>BlockLayout</code> so it can be passed a sequence of
sibling nodes, instead of a single node. Then, modify the algorithm that
constructs the layout tree so that any sequence of text-like elements
gets made into a single <code>BlockLayout</code>.</p>
<p><em>Run-ins</em>: A “run-in heading” is a heading that is drawn as
part of the next paragraph’s text.<span class="note-container"><span
class="note">The exercise names in this section could be considered
run-in headings. But since browser support for the
<code>display: run-in</code> property <a
href="https://caniuse.com/run-in">is poor</a>, this book actually
doesn’t use it; the headings are actually embedded in the next
paragraph.</span></span> Modify your browser to render
<code>&lt;h6&gt;</code> elements as run-in headings. You’ll need to
implement the previous exercise on anonymous block boxes, and then add a
special case for <code>&lt;h6&gt;</code> elements.</p>



<nav class="links">
  Chapter 5 of <a href="index.html" title="Table of Contents">Web Browser Engineering</a>.
  <a rel="prev" title="Previous chapter" href="html.html">&lt;</a>
  <a rel="next" title="Next chapter" href="styles.html">&gt;</a>
</nav>

<p>Did you find this chapter useful? <button id=feedback-button>Send us feedback!</button></p>

<footer>
  &copy; 2018&ndash;2023 <a href="https://pavpanchekha.com">Pavel Panchekha</a> &amp; <a href="https://twitter.com/chrishtr">Chris Harrelson</a>
</footer>

<script type="text/javascript" src="feedback.js"></script>
<script type="text/javascript" src="book.js"></script>
</body>
</html>
